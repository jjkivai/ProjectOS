   1              		.file	"kernel.cpp"
   2              	# GNU C++14 (Ubuntu 9.4.0-1ubuntu1~20.04.1) version 9.4.0 (x86_64-linux-gnu)
   3              	#	compiled by GNU C version 9.4.0, GMP version 6.2.0, MPFR version 4.0.2, MPC version 1.1.0, isl ve
   4              	
   5              	# GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
   6              	# options passed:  -imultilib 32 -imultiarch i386-linux-gnu -D_GNU_SOURCE
   7              	# kernel.cpp -m32 -mtune=generic -march=i686 -auxbase-strip kernel.asm -g
   8              	# -O2 -fverbose-asm -fasynchronous-unwind-tables -fstack-protector-strong
   9              	# -Wformat -Wformat-security -fstack-clash-protection -fcf-protection
  10              	# options enabled:  -fPIC -fPIE -faggressive-loop-optimizations
  11              	# -falign-functions -falign-jumps -falign-labels -falign-loops
  12              	# -fassume-phsa -fasynchronous-unwind-tables -fauto-inc-dec
  13              	# -fbranch-count-reg -fcaller-saves -fcode-hoisting
  14              	# -fcombine-stack-adjustments -fcommon -fcompare-elim -fcprop-registers
  15              	# -fcrossjumping -fcse-follow-jumps -fdefer-pop
  16              	# -fdelete-null-pointer-checks -fdevirtualize -fdevirtualize-speculatively
  17              	# -fdwarf2-cfi-asm -fearly-inlining -feliminate-unused-debug-types
  18              	# -fexceptions -fexpensive-optimizations -fforward-propagate
  19              	# -ffp-int-builtin-inexact -ffunction-cse -fgcse -fgcse-lm -fgnu-runtime
  20              	# -fgnu-unique -fguess-branch-probability -fhoist-adjacent-loads -fident
  21              	# -fif-conversion -fif-conversion2 -findirect-inlining -finline
  22              	# -finline-atomics -finline-functions-called-once -finline-small-functions
  23              	# -fipa-bit-cp -fipa-cp -fipa-icf -fipa-icf-functions -fipa-icf-variables
  24              	# -fipa-profile -fipa-pure-const -fipa-ra -fipa-reference
  25              	# -fipa-reference-addressable -fipa-sra -fipa-stack-alignment -fipa-vrp
  26              	# -fira-hoist-pressure -fira-share-save-slots -fira-share-spill-slots
  27              	# -fisolate-erroneous-paths-dereference -fivopts -fkeep-static-consts
  28              	# -fleading-underscore -flifetime-dse -flra-remat -flto-odr-type-merging
  29              	# -fmath-errno -fmerge-constants -fmerge-debug-strings
  30              	# -fmove-loop-invariants -fomit-frame-pointer -foptimize-sibling-calls
  31              	# -foptimize-strlen -fpartial-inlining -fpcc-struct-return -fpeephole
  32              	# -fpeephole2 -fplt -fprefetch-loop-arrays -free -freorder-blocks
  33              	# -freorder-blocks-and-partition -freorder-functions -frerun-cse-after-loop
  34              	# -fsched-critical-path-heuristic -fsched-dep-count-heuristic
  35              	# -fsched-group-heuristic -fsched-interblock -fsched-last-insn-heuristic
  36              	# -fsched-rank-heuristic -fsched-spec -fsched-spec-insn-heuristic
  37              	# -fsched-stalled-insns-dep -fschedule-fusion -fschedule-insns2
  38              	# -fsemantic-interposition -fshow-column -fshrink-wrap
  39              	# -fshrink-wrap-separate -fsigned-zeros -fsplit-ivs-in-unroller
  40              	# -fsplit-wide-types -fssa-backprop -fssa-phiopt -fstack-clash-protection
  41              	# -fstack-protector-strong -fstdarg-opt -fstore-merging -fstrict-aliasing
  42              	# -fstrict-volatile-bitfields -fsync-libcalls -fthread-jumps
  43              	# -ftoplevel-reorder -ftrapping-math -ftree-bit-ccp -ftree-builtin-call-dce
  44              	# -ftree-ccp -ftree-ch -ftree-coalesce-vars -ftree-copy-prop -ftree-cselim
  45              	# -ftree-dce -ftree-dominator-opts -ftree-dse -ftree-forwprop -ftree-fre
  46              	# -ftree-loop-if-convert -ftree-loop-im -ftree-loop-ivcanon
  47              	# -ftree-loop-optimize -ftree-parallelize-loops= -ftree-phiprop -ftree-pre
  48              	# -ftree-pta -ftree-reassoc -ftree-scev-cprop -ftree-sink -ftree-slsr
  49              	# -ftree-sra -ftree-switch-conversion -ftree-tail-merge -ftree-ter
  50              	# -ftree-vrp -funit-at-a-time -funwind-tables -fvar-tracking
  51              	# -fvar-tracking-assignments -fverbose-asm -fzero-initialized-in-bss -m32
  52              	# -m80387 -m96bit-long-double -malign-stringops
  53              	# -mavx256-split-unaligned-load -mavx256-split-unaligned-store
  54              	# -mfancy-math-387 -mfp-ret-in-387 -mglibc -mieee-fp -mlong-double-80
  55              	# -mno-red-zone -mno-sse4 -mpush-args -msahf -mstv -mtls-direct-seg-refs
  56              	# -mvzeroupper
  57              	
  58              		.text
  59              	.Ltext0:
  60              		.section	.rodata.str1.1,"aMS",@progbits,1
  61              	.LC0:
  62 ???? 57656C63 		.string	"Welcome to The OS\n"
  62      6F6D6520 
  62      746F2054 
  62      6865204F 
  62      530A00
  63              	.LC1:
  64 ???? 49535220 		.string	"ISR installed\n"
  64      696E7374 
  64      616C6C65 
  64      640A00
  65              	.LC2:
  66 ???? 456E6162 		.string	"Enabling interrupts...\n"
  66      6C696E67 
  66      20696E74 
  66      65727275 
  66      7074732E 
  67              	.LC3:
  68 ???? 496E7465 		.string	"Interrupts enabled\n"
  68      72727570 
  68      74732065 
  68      6E61626C 
  68      65640A00 
  69              		.section	.text.startup,"ax",@progbits
  70              		.p2align 4
  71              		.globl	main
  73              	main:
  74              	.LFB13:
  75              		.file 1 "kernel.cpp"
   1:kernel.cpp    **** #include "drivers/display.h"
   2:kernel.cpp    **** #include "cpu/ISR.h"
   3:kernel.cpp    **** 
   4:kernel.cpp    **** // class Kernel {
   5:kernel.cpp    **** // public:
   6:kernel.cpp    **** //     Kernel();
   7:kernel.cpp    **** //     void run();
   8:kernel.cpp    **** // };
   9:kernel.cpp    **** 
  10:kernel.cpp    **** // Kernel::Kernel() {
  11:kernel.cpp    **** //     // Initialize Display drivers
  12:kernel.cpp    **** //     Display display = Display();
  13:kernel.cpp    **** //     display.clear_screen(); // Can be called by default
  14:kernel.cpp    **** //     display.print_screen("Welcome to The OS\n");
  15:kernel.cpp    **** 
  16:kernel.cpp    **** //     // Initialize Interrupt Service
  17:kernel.cpp    **** //     ISR isr = ISR(display);
  18:kernel.cpp    **** //     isr.install_isr();
  19:kernel.cpp    **** //     display.print_screen("ISR installed\n");
  20:kernel.cpp    **** //     display.print_screen("Enabling interrupts...\n");
  21:kernel.cpp    **** //     isr.enable_interrupts();
  22:kernel.cpp    **** //     display.print_screen("Interrupts enabled\n");
  23:kernel.cpp    **** // }
  24:kernel.cpp    **** 
  25:kernel.cpp    **** // void Kernel::run() {
  26:kernel.cpp    **** 
  27:kernel.cpp    **** // }
  28:kernel.cpp    **** 
  29:kernel.cpp    **** 
  30:kernel.cpp    **** void register_handlers(ISR *isr);
  31:kernel.cpp    **** 
  32:kernel.cpp    **** ISR *isr_pointer = nullptr;
  33:kernel.cpp    **** 
  34:kernel.cpp    **** int main()
  35:kernel.cpp    **** {
  76              		.loc 1 35 1 view -0
  77              		.cfi_startproc
  78 ???? F30F1EFB 		endbr32	
  79 ???? 678D4C24 		leal	4(%esp), %ecx	#,
  79      04
  80              		.cfi_def_cfa 1, 0
  81 ???? 83E4F0   		andl	$-16, %esp	#,
  82              		pushl	-4(%ecx)	#
  83              		pushl	%ebp	#
  84 ???? 89E5     		movl	%esp, %ebp	#,
  85              		.cfi_escape 0x10,0x5,0x2,0x75,0
  86              		pushl	%edi	#
  87              		pushl	%esi	#
  88              		.cfi_escape 0x10,0x7,0x2,0x75,0x7c
  89              		.cfi_escape 0x10,0x6,0x2,0x75,0x78
  90              	# kernel.cpp:38:     display.clear_screen(); // Can be called by default
  36:kernel.cpp    ****     // Initialize Display drivers
  37:kernel.cpp    ****     Display display = Display();
  38:kernel.cpp    ****     display.clear_screen(); // Can be called by default
  91              		.loc 1 38 25 is_stmt 0 view .LVU1
  92 ???? 678DB5D3 		leal	-3117(%ebp), %esi	#, tmp85
  92      F3FFFF
  93              	.LBB7:
  94              	.LBB8:
  95              	.LBB9:
  96              	# cpu/ISR.h:98:         ISR(Display& display) : disp(display) {
  97              		.file 2 "cpu/ISR.h"
   1:cpu/ISR.h     **** // HEADER FILE DEFINING INTERRUPT SERVICES AND DESCRIPTORS
   2:cpu/ISR.h     **** #pragma once
   3:cpu/ISR.h     **** #include "IDT.h"
   4:cpu/ISR.h     **** #include "../drivers/display.h"
   5:cpu/ISR.h     **** 
   6:cpu/ISR.h     **** /* ISRs reserved for ISR exceptions */
   7:cpu/ISR.h     **** extern "C" void isr0();
   8:cpu/ISR.h     **** extern "C" void isr1();
   9:cpu/ISR.h     **** extern "C" void isr2();
  10:cpu/ISR.h     **** extern "C" void isr3();
  11:cpu/ISR.h     **** extern "C" void isr4();
  12:cpu/ISR.h     **** extern "C" void isr5();
  13:cpu/ISR.h     **** extern "C" void isr6();
  14:cpu/ISR.h     **** extern "C" void isr7();
  15:cpu/ISR.h     **** extern "C" void isr8();
  16:cpu/ISR.h     **** extern "C" void isr9();
  17:cpu/ISR.h     **** extern "C" void isr10();
  18:cpu/ISR.h     **** extern "C" void isr11();
  19:cpu/ISR.h     **** extern "C" void isr12();
  20:cpu/ISR.h     **** extern "C" void isr13();
  21:cpu/ISR.h     **** extern "C" void isr14();
  22:cpu/ISR.h     **** extern "C" void isr15();
  23:cpu/ISR.h     **** extern "C" void isr16();
  24:cpu/ISR.h     **** extern "C" void isr17();
  25:cpu/ISR.h     **** extern "C" void isr18();
  26:cpu/ISR.h     **** extern "C" void isr19();
  27:cpu/ISR.h     **** extern "C" void isr20();
  28:cpu/ISR.h     **** extern "C" void isr21();
  29:cpu/ISR.h     **** extern "C" void isr22();
  30:cpu/ISR.h     **** extern "C" void isr23();
  31:cpu/ISR.h     **** extern "C" void isr24();
  32:cpu/ISR.h     **** extern "C" void isr25();
  33:cpu/ISR.h     **** extern "C" void isr26();
  34:cpu/ISR.h     **** extern "C" void isr27();
  35:cpu/ISR.h     **** extern "C" void isr28();
  36:cpu/ISR.h     **** extern "C" void isr29();
  37:cpu/ISR.h     **** extern "C" void isr30();
  38:cpu/ISR.h     **** extern "C" void isr31();
  39:cpu/ISR.h     **** 
  40:cpu/ISR.h     **** /* Interrupt requests*/
  41:cpu/ISR.h     **** extern "C" void irq0();
  42:cpu/ISR.h     **** extern "C" void irq1();
  43:cpu/ISR.h     **** extern "C" void irq2();
  44:cpu/ISR.h     **** extern "C" void irq3();
  45:cpu/ISR.h     **** extern "C" void irq4();
  46:cpu/ISR.h     **** extern "C" void irq5();
  47:cpu/ISR.h     **** extern "C" void irq6();
  48:cpu/ISR.h     **** extern "C" void irq7();
  49:cpu/ISR.h     **** extern "C" void irq8();
  50:cpu/ISR.h     **** extern "C" void irq9();
  51:cpu/ISR.h     **** extern "C" void irq10();
  52:cpu/ISR.h     **** extern "C" void irq11();
  53:cpu/ISR.h     **** extern "C" void irq12();
  54:cpu/ISR.h     **** extern "C" void irq13();
  55:cpu/ISR.h     **** extern "C" void irq14();
  56:cpu/ISR.h     **** extern "C" void irq15();
  57:cpu/ISR.h     **** 
  58:cpu/ISR.h     **** 
  59:cpu/ISR.h     **** /* Interrupt requests for hardware exceptions*/
  60:cpu/ISR.h     **** #define IRQ0 32
  61:cpu/ISR.h     **** #define IRQ1 33
  62:cpu/ISR.h     **** #define IRQ2 34
  63:cpu/ISR.h     **** #define IRQ3 35
  64:cpu/ISR.h     **** #define IRQ4 36
  65:cpu/ISR.h     **** #define IRQ5 37
  66:cpu/ISR.h     **** #define IRQ6 38
  67:cpu/ISR.h     **** #define IRQ7 39
  68:cpu/ISR.h     **** #define IRQ8 40
  69:cpu/ISR.h     **** #define IRQ9 41
  70:cpu/ISR.h     **** #define IRQ10 42
  71:cpu/ISR.h     **** #define IRQ11 43
  72:cpu/ISR.h     **** #define IRQ12 44
  73:cpu/ISR.h     **** #define IRQ13 45
  74:cpu/ISR.h     **** #define IRQ14 46
  75:cpu/ISR.h     **** #define IRQ15 47
  76:cpu/ISR.h     **** 
  77:cpu/ISR.h     **** 
  78:cpu/ISR.h     **** struct __attribute__((packed)) InterruptRegister {
  79:cpu/ISR.h     ****     uint32_t ds; // Data segment selector
  80:cpu/ISR.h     ****     uint32_t edi, esi, ebp, esp, ebx, edx, ecx, eax; /* Pushed by pusha. */
  81:cpu/ISR.h     ****     uint32_t int_no, err_code; /* Interrupt number and error code (if applicable) */
  82:cpu/ISR.h     ****     uint32_t eip, cs, eflags, useresp, ss; /* Pushed by the processor automatically */
  83:cpu/ISR.h     **** };
  84:cpu/ISR.h     **** extern "C" void interrupt_handler(InterruptRegister *reg);
  85:cpu/ISR.h     **** extern "C" void interrupt_request_handler(InterruptRegister *reg);
  86:cpu/ISR.h     **** 
  87:cpu/ISR.h     **** class ISR {
  88:cpu/ISR.h     ****     private:
  89:cpu/ISR.h     ****         IDT Idt = IDT();
  90:cpu/ISR.h     ****         Display &disp;
  91:cpu/ISR.h     ****         /* It matches how 'pusha' would push data to stack */
  92:cpu/ISR.h     **** 
  93:cpu/ISR.h     ****         typedef void (*InterruptHandler)(InterruptRegister *reg); //Defining type of interrupt hand
  94:cpu/ISR.h     ****         
  95:cpu/ISR.h     ****         InterruptHandler handlers[ENTRIES];
  96:cpu/ISR.h     **** 
  97:cpu/ISR.h     ****     public:
  98:cpu/ISR.h     ****         ISR(Display& display) : disp(display) {
  98              		.loc 2 98 45 view .LVU2
  99 ???? 678DBDD4 		leal	-3116(%ebp), %edi	#, tmp88
  99      F3FFFF
 100              	.LBE9:
 101              	.LBE8:
 102              	.LBE7:
 103              	# kernel.cpp:35: {
  35:kernel.cpp    ****     // Initialize Display drivers
 104              		.loc 1 35 1 view .LVU3
 105              		pushl	%ebx	#
 106              		.cfi_escape 0x10,0x3,0x2,0x75,0x74
 107 ???? E8000000 		call	__x86.get_pc_thunk.bx	#
 107      00
 108 ???? 81C30000 		addl	$_GLOBAL_OFFSET_TABLE_, %ebx	# tmp82,
 108      0000
 109              		pushl	%ecx	#
 110              		.cfi_escape 0xf,0x3,0x75,0x70,0x6
 111 ???? 81EC340C 		subl	$3124, %esp	#,
 111      0000
 112              	# kernel.cpp:35: {
  35:kernel.cpp    ****     // Initialize Display drivers
 113              		.loc 1 35 1 view .LVU4
 114 ???? 658B0425 		movl	%gs:20, %eax	# MEM[(<address-space-2> unsigned int *)20B], tmp104
 114      14000000 
 115 ???? 678945E4 		movl	%eax, -28(%ebp)	# tmp104, D.2418
 116 ???? 31C0     		xorl	%eax, %eax	# tmp104
  37:kernel.cpp    ****     display.clear_screen(); // Can be called by default
 117              		.loc 1 37 5 is_stmt 1 view .LVU5
 118              		.loc 1 38 5 view .LVU6
 119              	# kernel.cpp:38:     display.clear_screen(); // Can be called by default
 120              		.loc 1 38 25 is_stmt 0 view .LVU7
 121              		pushl	%esi	# tmp85
 122 ???? E8000000 		call	_ZN7Display12clear_screenEv@PLT	#
 122      00
 123              	.LVL0:
  39:kernel.cpp    ****     display.print_screen("Welcome to The OS\n");
 124              		.loc 1 39 5 is_stmt 1 view .LVU8
 125              	# kernel.cpp:39:     display.print_screen("Welcome to The OS\n");
 126              		.loc 1 39 25 is_stmt 0 view .LVU9
 127              		popl	%eax	#
 128 ???? 678D8300 		leal	.LC0@GOTOFF(%ebx), %eax	#, tmp86
****  Error: 8-byte relocation cannot be applied to 4-byte field
 128      000000
 129              		popl	%edx	#
 130              		pushl	%eax	# tmp86
 131              		pushl	%esi	# tmp85
 132 ???? E8000000 		call	_ZN7Display12print_screenEPKc@PLT	#
 132      00
 133              	.LVL1:
  40:kernel.cpp    **** 
  41:kernel.cpp    ****     // Initialize Interrupt Service
  42:kernel.cpp    ****     ISR isr = ISR(display);
 134              		.loc 1 42 5 is_stmt 1 view .LVU10
 135              	.LBB14:
 136              	.LBI7:
 137              		.loc 2 98 9 view .LVU11
 138              	.LBB12:
 139              	.LBB10:
 140              	# cpu/ISR.h:98:         ISR(Display& display) : disp(display) {
 141              		.loc 2 98 45 is_stmt 0 view .LVU12
 142 ???? 31C0     		xorl	%eax, %eax	# tmp89
 143 ???? B9030200 		movl	$515, %ecx	#, tmp90
 143      00
 144 ???? 6789B5E0 		movl	%esi, -1056(%ebp)	# tmp85, isr.disp
 144      FBFFFF
 145              	.LVL2:
 146              		.loc 2 98 45 view .LVU13
 147              	.LBE10:
 148              	.LBE12:
 149              	.LBE14:
  43:kernel.cpp    ****     isr.install_isr();
 150              		.loc 1 43 5 is_stmt 1 view .LVU14
 151              	.LBB15:
 152              	.LBB13:
 153              	.LBB11:
 154              	# cpu/ISR.h:98:         ISR(Display& display) : disp(display) {
 155              		.loc 2 98 45 is_stmt 0 view .LVU15
 156 ???? F3AB     		rep stosl
 157              	.LBE11:
 158              	.LBE13:
 159              	.LBE15:
 160              	# kernel.cpp:43:     isr.install_isr();
 161              		.loc 1 43 20 view .LVU16
 162 ???? 678DBDD4 		leal	-3116(%ebp), %edi	#, tmp92
 162      F3FFFF
 163 ???? 67893C24 		movl	%edi, (%esp)	# tmp92,
 164 ???? E8000000 		call	_ZN3ISR11install_isrEv@PLT	#
 164      00
 165              	.LVL3:
  44:kernel.cpp    ****     register_handlers(&isr);
 166              		.loc 1 44 5 is_stmt 1 view .LVU17
 167              	.LBB16:
 168              	.LBI16:
  45:kernel.cpp    ****     display.print_screen("ISR installed\n");
  46:kernel.cpp    ****     display.print_screen("Enabling interrupts...\n");
  47:kernel.cpp    ****     isr.enable_interrupts();
  48:kernel.cpp    ****     display.print_screen("Interrupts enabled\n");
  49:kernel.cpp    ****     /* trigger divide by 0 exception */
  50:kernel.cpp    ****     __asm__ __volatile__("int $0");
  51:kernel.cpp    ****     /* This causes error -> loops indefinetely*/
  52:kernel.cpp    ****     int a = 5;
  53:kernel.cpp    ****     int b = 0;
  54:kernel.cpp    ****     int c = a / b;
  55:kernel.cpp    ****     /* trigger overflow exception */
  56:kernel.cpp    ****     __asm__ __volatile__("int $4");
  57:kernel.cpp    ****     /* TODO: Setup keyboard*/
  58:kernel.cpp    ****     /* TODO: Setup timers*/
  59:kernel.cpp    ****     /* TODO: Setup dynamic memory*/
  60:kernel.cpp    **** 
  61:kernel.cpp    ****     return 0;
  62:kernel.cpp    **** 
  63:kernel.cpp    **** }
  64:kernel.cpp    **** void register_handlers(ISR *isr) {
 169              		.loc 1 64 6 view .LVU18
 170              	.LBB17:
  65:kernel.cpp    ****     isr_pointer = isr;
 171              		.loc 1 65 5 view .LVU19
 172              	.LBE17:
 173              	.LBE16:
 174              	# kernel.cpp:45:     display.print_screen("ISR installed\n");
  45:kernel.cpp    ****     display.print_screen("ISR installed\n");
 175              		.loc 1 45 25 is_stmt 0 view .LVU20
 176              		popl	%ecx	#
 177              		popl	%eax	#
 178 ???? 678D8300 		leal	.LC1@GOTOFF(%ebx), %eax	#, tmp94
****  Error: 8-byte relocation cannot be applied to 4-byte field
 178      000000
 179              		pushl	%eax	# tmp94
 180              		pushl	%esi	# tmp85
 181              	.LBB19:
 182              	.LBB18:
 183              	# kernel.cpp:65:     isr_pointer = isr;
 184              		.loc 1 65 17 view .LVU21
 185 ???? 6789BB00 		movl	%edi, isr_pointer@GOTOFF(%ebx)	# tmp92, isr_pointer
****  Error: 8-byte relocation cannot be applied to 4-byte field
 185      000000
 186              	.LVL4:
 187              		.loc 1 65 17 view .LVU22
 188              	.LBE18:
 189              	.LBE19:
  45:kernel.cpp    ****     display.print_screen("ISR installed\n");
 190              		.loc 1 45 5 is_stmt 1 view .LVU23
 191              	# kernel.cpp:45:     display.print_screen("ISR installed\n");
  45:kernel.cpp    ****     display.print_screen("ISR installed\n");
 192              		.loc 1 45 25 is_stmt 0 view .LVU24
 193 ???? E8000000 		call	_ZN7Display12print_screenEPKc@PLT	#
 193      00
 194              	.LVL5:
  46:kernel.cpp    ****     isr.enable_interrupts();
 195              		.loc 1 46 5 is_stmt 1 view .LVU25
 196              	# kernel.cpp:46:     display.print_screen("Enabling interrupts...\n");
  46:kernel.cpp    ****     isr.enable_interrupts();
 197              		.loc 1 46 25 is_stmt 0 view .LVU26
 198              		popl	%eax	#
 199 ???? 678D8300 		leal	.LC2@GOTOFF(%ebx), %eax	#, tmp96
****  Error: 8-byte relocation cannot be applied to 4-byte field
 199      000000
 200              		popl	%edx	#
 201              		pushl	%eax	# tmp96
 202              		pushl	%esi	# tmp85
 203 ???? E8000000 		call	_ZN7Display12print_screenEPKc@PLT	#
 203      00
 204              	.LVL6:
  47:kernel.cpp    ****     display.print_screen("Interrupts enabled\n");
 205              		.loc 1 47 5 is_stmt 1 view .LVU27
 206              	# kernel.cpp:47:     isr.enable_interrupts();
  47:kernel.cpp    ****     display.print_screen("Interrupts enabled\n");
 207              		.loc 1 47 26 is_stmt 0 view .LVU28
 208 ???? 67893C24 		movl	%edi, (%esp)	# tmp92,
 209 ???? E8000000 		call	_ZN3ISR17enable_interruptsEv@PLT	#
 209      00
 210              	.LVL7:
  48:kernel.cpp    ****     /* trigger divide by 0 exception */
 211              		.loc 1 48 5 is_stmt 1 view .LVU29
 212              	# kernel.cpp:48:     display.print_screen("Interrupts enabled\n");
  48:kernel.cpp    ****     /* trigger divide by 0 exception */
 213              		.loc 1 48 25 is_stmt 0 view .LVU30
 214 ???? 678D8300 		leal	.LC3@GOTOFF(%ebx), %eax	#, tmp99
****  Error: 8-byte relocation cannot be applied to 4-byte field
 214      000000
 215              		popl	%ecx	#
 216              		popl	%edi	#
 217              		pushl	%eax	# tmp99
 218              		pushl	%esi	# tmp85
 219 ???? E8000000 		call	_ZN7Display12print_screenEPKc@PLT	#
 219      00
 220              	.LVL8:
  50:kernel.cpp    ****     /* This causes error -> loops indefinetely*/
 221              		.loc 1 50 5 is_stmt 1 view .LVU31
 222              	# kernel.cpp:50:     __asm__ __volatile__("int $0");
  50:kernel.cpp    ****     /* This causes error -> loops indefinetely*/
 223              		.loc 1 50 35 is_stmt 0 view .LVU32
 224              	#APP
 225              	# 50 "kernel.cpp" 1
  52:kernel.cpp    ****     int b = 0;
 226              		int $0
 227              	# 0 "" 2
 228              		.loc 1 52 5 is_stmt 1 view .LVU33
 229              	.LVL9:
  53:kernel.cpp    ****     int c = a / b;
 230              		.loc 1 53 5 view .LVU34
  54:kernel.cpp    ****     /* trigger overflow exception */
 231              		.loc 1 54 5 view .LVU35
  56:kernel.cpp    ****     /* TODO: Setup keyboard*/
 232              		.loc 1 56 5 view .LVU36
 233              	# kernel.cpp:56:     __asm__ __volatile__("int $4");
  56:kernel.cpp    ****     /* TODO: Setup keyboard*/
 234              		.loc 1 56 35 is_stmt 0 view .LVU37
 235              	# 56 "kernel.cpp" 1
  61:kernel.cpp    **** 
 236              		int $4
 237              	# 0 "" 2
 238              		.loc 1 61 5 is_stmt 1 view .LVU38
 239              	#NO_APP
 240 ???? 83C410   		addl	$16, %esp	#,
 241              	# kernel.cpp:63: }
  63:kernel.cpp    **** void register_handlers(ISR *isr) {
 242              		.loc 1 63 1 is_stmt 0 view .LVU39
 243 ???? 678B45E4 		movl	-28(%ebp), %eax	# D.2418, tmp105
 244 ???? 65330425 		xorl	%gs:20, %eax	# MEM[(<address-space-2> unsigned int *)20B], tmp105
 244      14000000 
 245 ???? 750B     		jne	.L5	#,
 246 ???? 678D65F0 		leal	-16(%ebp), %esp	#,
 247 ???? 31C0     		xorl	%eax, %eax	#
 248              		popl	%ecx	#
 249              		.cfi_remember_state
 250              		.cfi_restore 1
 251              		.cfi_def_cfa 1, 0
 252              		popl	%ebx	#
 253              		.cfi_restore 3
 254              		popl	%esi	#
 255              		.cfi_restore 6
 256              		popl	%edi	#
 257              		.cfi_restore 7
 258              		popl	%ebp	#
 259              		.cfi_restore 5
 260 ???? 678D61FC 		leal	-4(%ecx), %esp	#,
 261              		.cfi_def_cfa 4, 4
 262 ???? C3       		ret	
 263              	.L5:
 264              		.cfi_restore_state
 265 ???? E8000000 		call	__stack_chk_fail_local	#
 265      00
 266              	.LVL10:
 267              		.cfi_endproc
 268              	.LFE13:
 270              		.text
 271              		.p2align 4
 272              		.globl	_Z17register_handlersP3ISR
 274              	_Z17register_handlersP3ISR:
 275              	.LVL11:
 276              	.LFB14:
  64:kernel.cpp    ****     isr_pointer = isr;
 277              		.loc 1 64 34 is_stmt 1 view -0
 278              		.cfi_startproc
  64:kernel.cpp    ****     isr_pointer = isr;
 279              		.loc 1 64 34 is_stmt 0 view .LVU41
 280 ???? F30F1EFB 		endbr32	
 281              		.loc 1 65 5 is_stmt 1 view .LVU42
 282 ???? E8000000 		call	__x86.get_pc_thunk.ax	#
 282      00
 283 ???? 05000000 		addl	$_GLOBAL_OFFSET_TABLE_, %eax	# tmp82,
 283      00
 284              	# kernel.cpp:65:     isr_pointer = isr;
 285              		.loc 1 65 17 is_stmt 0 view .LVU43
 286 ???? 678B5424 		movl	4(%esp), %edx	# isr, isr
 286      04
 287 ???? 67899000 		movl	%edx, isr_pointer@GOTOFF(%eax)	# isr, isr_pointer
****  Error: 8-byte relocation cannot be applied to 4-byte field
 287      000000
 288              	# kernel.cpp:66: }
  66:kernel.cpp    **** }
 289              		.loc 1 66 1 view .LVU44
 290 ???? C3       		ret	
 291              		.cfi_endproc
 292              	.LFE14:
 294 ???? 0F1F4400 		.p2align 4
 294      00
 295              		.globl	interrupt_handler
 297              	interrupt_handler:
 298              	.LVL12:
 299              	.LFB15:
  67:kernel.cpp    **** 
  68:kernel.cpp    **** extern "C" void interrupt_handler(InterruptRegister *reg) {
 300              		.loc 1 68 59 is_stmt 1 view -0
 301              		.cfi_startproc
 302              		.loc 1 68 59 is_stmt 0 view .LVU46
 303 ???? F30F1EFB 		endbr32	
  69:kernel.cpp    ****     isr_pointer->__interrupt_handler(reg);
 304              		.loc 1 69 5 is_stmt 1 view .LVU47
 305              	# kernel.cpp:68: extern "C" void interrupt_handler(InterruptRegister *reg) {
  68:kernel.cpp    ****     isr_pointer->__interrupt_handler(reg);
 306              		.loc 1 68 59 is_stmt 0 view .LVU48
 307              		pushl	%ebx	#
 308              		.cfi_def_cfa_offset 8
 309              		.cfi_offset 3, -8
 310 ???? E8000000 		call	__x86.get_pc_thunk.bx	#
 310      00
 311 ???? 81C30000 		addl	$_GLOBAL_OFFSET_TABLE_, %ebx	# tmp82,
 311      0000
 312 ???? 83EC10   		subl	$16, %esp	#,
 313              		.cfi_def_cfa_offset 24
 314              	# kernel.cpp:69:     isr_pointer->__interrupt_handler(reg);
 315              		.loc 1 69 37 view .LVU49
 316              		pushl	24(%esp)	# reg
 317              		.cfi_def_cfa_offset 28
 318              		pushl	isr_pointer@GOTOFF(%ebx)	# isr_pointer
 319              		.cfi_def_cfa_offset 32
 320 ???? E8000000 		call	_ZN3ISR19__interrupt_handlerEP17InterruptRegister@PLT	#
 320      00
 321              	.LVL13:
 322              	# kernel.cpp:70: }
  70:kernel.cpp    **** }
 323              		.loc 1 70 1 view .LVU50
 324 ???? 83C418   		addl	$24, %esp	#,
 325              		.cfi_def_cfa_offset 8
 326              		popl	%ebx	#
 327              		.cfi_restore 3
 328              		.cfi_def_cfa_offset 4
 329 ???? C3       		ret	
 330              		.cfi_endproc
 331              	.LFE15:
 333 ???? 0F1F4400 		.p2align 4
 333      00
 334              		.globl	interrupt_request_handler
 336              	interrupt_request_handler:
 337              	.LVL14:
 338              	.LFB16:
  71:kernel.cpp    **** extern "C" void interrupt_request_handler(InterruptRegister *reg) {
 339              		.loc 1 71 67 is_stmt 1 view -0
 340              		.cfi_startproc
 341              		.loc 1 71 67 is_stmt 0 view .LVU52
 342 ???? F30F1EFB 		endbr32	
  72:kernel.cpp    ****         isr_pointer->__interrupt_request_handler(reg);
 343              		.loc 1 72 9 is_stmt 1 view .LVU53
 344              	# kernel.cpp:71: extern "C" void interrupt_request_handler(InterruptRegister *reg) {
  71:kernel.cpp    **** extern "C" void interrupt_request_handler(InterruptRegister *reg) {
 345              		.loc 1 71 67 is_stmt 0 view .LVU54
 346              		pushl	%ebx	#
 347              		.cfi_def_cfa_offset 8
 348              		.cfi_offset 3, -8
 349 ???? E8000000 		call	__x86.get_pc_thunk.bx	#
 349      00
 350 ???? 81C30000 		addl	$_GLOBAL_OFFSET_TABLE_, %ebx	# tmp82,
 350      0000
 351 ???? 83EC10   		subl	$16, %esp	#,
 352              		.cfi_def_cfa_offset 24
 353              	# kernel.cpp:72:         isr_pointer->__interrupt_request_handler(reg);
 354              		.loc 1 72 49 view .LVU55
 355              		pushl	24(%esp)	# reg
 356              		.cfi_def_cfa_offset 28
 357              		pushl	isr_pointer@GOTOFF(%ebx)	# isr_pointer
 358              		.cfi_def_cfa_offset 32
 359 ???? E8000000 		call	_ZN3ISR27__interrupt_request_handlerEP17InterruptRegister@PLT	#
 359      00
 360              	.LVL15:
 361              	# kernel.cpp:73: }
  73:kernel.cpp    **** }
 362              		.loc 1 73 1 view .LVU56
 363 ???? 83C418   		addl	$24, %esp	#,
 364              		.cfi_def_cfa_offset 8
 365              		popl	%ebx	#
 366              		.cfi_restore 3
 367              		.cfi_def_cfa_offset 4
 368 ???? C3       		ret	
 369              		.cfi_endproc
 370              	.LFE16:
 372              		.globl	isr_pointer
 373              		.bss
 374              		.align 4
 377              	isr_pointer:
 378 ???? 00000000 		.zero	4
 379              		.section	.text.__x86.get_pc_thunk.ax,"axG",@progbits,__x86.get_pc_thunk.ax,comdat
 380              		.globl	__x86.get_pc_thunk.ax
 381              		.hidden	__x86.get_pc_thunk.ax
 383              	__x86.get_pc_thunk.ax:
 384              	.LFB17:
 385              		.cfi_startproc
 386 ???? 678B0424 		movl	(%esp), %eax	#,
 387 ???? C3       		ret	
 388              		.cfi_endproc
 389              	.LFE17:
 390              		.section	.text.__x86.get_pc_thunk.bx,"axG",@progbits,__x86.get_pc_thunk.bx,comdat
 391              		.globl	__x86.get_pc_thunk.bx
 392              		.hidden	__x86.get_pc_thunk.bx
 394              	__x86.get_pc_thunk.bx:
 395              	.LFB18:
 396              		.cfi_startproc
 397 ???? 678B1C24 		movl	(%esp), %ebx	#,
 398 ???? C3       		ret	
 399              		.cfi_endproc
 400              	.LFE18:
 401              		.text
 402              	.Letext0:
 403              		.file 3 "/usr/include/bits/types.h"
 404              		.file 4 "/usr/include/bits/stdint-uintn.h"
 405              		.file 5 "drivers/display.h"
 406              		.file 6 "cpu/IDT.h"
 2385              		.section	.note.gnu.property,"a"
 2386              		.align 4
 2387 ???? 04000000 		.long	 1f - 0f
 2388 ???? 0C000000 		.long	 4f - 1f
 2389 ???? 05000000 		.long	 5
 2390              	0:
 2391 ???? 474E5500 		.string	 "GNU"
 2392              	1:
 2393              		.align 4
 2394 ???? 020000C0 		.long	 0xc0000002
 2395 ???? 04000000 		.long	 3f - 2f
 2396              	2:
 2397 ???? 03000000 		.long	 0x3
 2398              	3:
 2399              		.align 4
 2400              	4:
